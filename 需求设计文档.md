# Role Definition
你是一位拥有 20 年经验的 **资深游戏引擎架构师 (Principal Game Architect)**，精通 Python 高性能编程、PyQt5 图形渲染及博弈论算法。
**核心任务**：根据这份“全栈实现蓝图”，编写一份**生产级 (Production-Ready)、逻辑严密、无认知冲突**的中国象棋客户端代码。
**执行原则**：
1.  **单一真理来源**：代码中的逻辑必须严格遵循本文档定义的物理规则、数据结构和记谱标准，严禁猜测。
2.  **类型安全**：必须在 Python 3.10+ 环境下使用严格的 Type Hints (e.g., `def func(a: int) -> list[str]:`)。
3.  **鲁棒性**：对坐标越界、空指针、状态机非法流转进行防御性编程。


# 1. 强制技术栈 (Mandatory Tech Stack)
* **Language**: Python 3.10+
* **GUI Framework**: `PyQt5` (QtWidgets, QtGui, QtCore)。
    * **Architecture**: `QGraphicsScene` + `QGraphicsView` (高性能 2D 渲染)。
    * **Concurrency**: `QThread` (用于 AI 思考和智能提示计算，**严禁**阻塞主 UI 线程)。
* **Audio**: `QSoundEffect` (预留接口)。
* **Project Structure**: 模块化设计 (`core`, `ai`, `ui`, `utils`)。


# 2. 核心数据结构与坐标系 (Core Logic)

## 2.1 坐标系统 (Coordinate System)
* **逻辑坐标**: 笛卡尔坐标 `(row, col)`。
    * `row`: 0 (红方底线) -> 9 (黑方底线)。
    * `col`: 0 (红方左路) -> 8 (红方右路)。
* **阵营定义**: `RED = 1` (先手/玩家), `BLACK = -1` (后手/电脑)。
* **状态管理**:
    * 使用 **FEN (Forsyth-Edwards Notation)** 字符串作为棋局状态的唯一快照。
    * 内部维护 `history: list[str]` 用于“悔棋”功能的实现。

## 2.2 棋子编码
* 红方: `R`(车), `N`(马), `B`(相), `A`(仕), `K`(帅), `C`(炮), `P`(兵)
* 黑方: `r`(车), `n`(马), `b`(象), `a`(士), `k`(将), `c`(炮), `p`(卒)

---

# 3. 规则引擎 (Strict Rule Engine)
**警告**：必须硬编码以下《中国象棋竞赛规则》逻辑，禁止使用模糊算法。

## 3.1 移动逻辑 (Movement Deltas)
对于移动 `(r1, c1) -> (r2, c2)`，定义 `dr = r2 - r1`, `dc = c2 - c1`。
1.  **马 (Knight)**:
    * 移动: `abs(dr), abs(dc)` 为 `(2, 1)` 或 `(1, 2)`。
    * **蹩腿检测**:
        * 若 `abs(dr) == 2`: 检查 `(r1 + dr/2, c1)` 是否有子。
        * 若 `abs(dc) == 2`: 检查 `(r1, c1 + dc/2)` 是否有子。
2.  **象 (Elephant)**:
    * 移动: `abs(dr) == 2` 且 `abs(dc) == 2`。
    * **塞象眼**: 检查 `(r1 + dr/2, c1 + dc/2)` 是否有子。
    * **河界**: 红象 `r2 <= 4`，黑象 `r2 >= 5`。
3.  **士/帅 (Advisor/King)**:
    * 限制在各自“九宫”坐标范围内。
4.  **兵 (Pawn)**:
    * 未过河只许直进；过河后可横走。严禁后退。
5.  **飞将 (Flying General)**:
    * 任意移动结束后，检测红帅与黑将是否在同一 `col`。若是，检查两者之间是否有棋子阻隔。若无阻隔，则该移动**非法**。

## 3.2 胜负判定
1.  **将军 (Check)**: 己方移动后，敌方将领在己方攻击范围内。
2.  **困毙 (Stalemate)**: 轮到某方走棋时，若无任何合法移动，判**负** (Loss)。
3.  **长将**: (可选实现) 若检测到重复局面 3 次且一直处于将军状态，判负。

---

# 4. 专业记谱引擎 (Notation Engine)
必须实现独立模块 `NotationGenerator`，将 `(move, board)` 转换为标准中文记谱（如“炮二平五”）。

## 4.1 坐标映射 (Visual Mapping)
* **红方视角** (Bottom): 从右向左数 (1-9)。
    * `col 0` -> "九", `col 8` -> "一"。
* **黑方视角** (Top): 从右向左数 (1-9)。
    * `col 0` -> "1", `col 8` -> "9"。
* **注意**: 记谱中的“进/退”步数是绝对距离；“平/进/退”到某列是视觉列号。

## 4.2 歧义处理
* **同列多兵**: 检测起点列 `c1` 是否有多个同色同种棋子。
    * 区分“前兵”、“后兵”（甚至“中兵”）。
    * 输出格式调整为：`前兵进一` 代替 `兵三进一`。

---

# 5. AI 与智能提示引擎 (AI & Hint Core)
必须实现一个高复用的 `AIEngine` 类，支持多线程运行。

## 5.1 评估与搜索 (Evaluation & Search)
* **估值函数**: 基于材质 (Material) + 位置表 (Position Table/PST)。
    * 材质参考: 车=90, 炮=45, 马=40, 相/士=20, 兵=(10/20), 帅=10000。
* **搜索算法**: `Minimax` 框架 + `Alpha-Beta Pruning`。
    * **难度分级**:
        * Easy: Depth = 2
        * Hard: Depth = 4 (需优化剪枝效率)

## 5.2 提示功能 (Smart Hint)
* **复用逻辑**: “提示”功能本质上是让 AI 站在**当前玩家**的立场上计算最佳一步。
* **线程安全**: 必须通过 `QThread` 异步计算，完成后发送信号 `hint_ready(move)`，在界面上高亮建议落点（如绿色圆点）。

---

# 6. 界面与交互设计 (UI/UX)

## 6.1 主窗口布局
* **左侧**: `GameView` (继承自 `QGraphicsView`)。
    * 背景: 木纹棋盘 SVG/PNG。
    * 棋子: 绘制字符或图片，选中时显示**泛光特效**。
    * **Layering**: 背景层 -> 棋子层 -> 提示/动画层。
* **右侧**: `ControlPanel` (`QWidget`)。
    * **棋谱记录**: `QListWidget`，实时追加中文记谱。
    * **设置区**:
        * 模式选择: [PVP] / [PVE-小白] / [PVE-初级]/[PVE-中级]/[PVE-高级]/[PVE-大师]。
        * 执红/执黑选择。
    * **操作区**:
        * `[开始游戏]`
        * `[悔棋]` (Undo)
        * `[智能提示]` (Hint) - 点击后异步请求 AI。
        * `[认输]`

qt界面的样式优化请采用qt-material,这个是他的github连接：https://github.com/UN-GCPDS/qt-material


## 6.2 交互状态机 (FSM)
* `IDLE`: 等待开始。
* `USER_TURN`: 玩家操作中（允许点击、提示）。
* `AI_THINKING`: 电脑思考中（**锁定棋盘**，禁止点击，显示进度条或沙漏）。
* `HINT_CALCULATING`: 提示计算中（允许取消，但在结果返回前锁定移动）。
* `GAME_OVER`: 结算画面。

## 其他功能需求
1. 吃子要有动画过渡，走棋看起来不能是瞬间移动的

# 7. 分步实现指令 (Step-by-Step Implementation)
请按照以下阶段生成代码，确保每个阶段的代码都可以独立运行或通过单元测试。

**Phase 1: 核心逻辑基石 (`core/`)**
1.  `constants.py`: 定义坐标、棋子分值、颜色常量。
2.  `board.py`: 实现 FEN 解析、棋盘状态管理。
3.  `rules.py`: 实现**严格的** `get_legal_moves` (含马腿/飞将) 和 `is_check`。
4.  `notation.py`: 实现中文记谱生成逻辑。

**Phase 2: AI 与线程 (`ai/`)**
1.  `evaluation.py`: 静态估值函数。
2.  `search.py`: Minimax 算法。
3.  `worker.py`: 封装 `QThread`，支持 `mode='AI_MOVE'` 和 `mode='HINT'` 两种请求。

**Phase 3: 图形界面与组装 (`ui/`)**
1.  `pieces.py`: 自定义 `QGraphicsItem`。
2.  `board_view.py`: 处理点击事件、坐标转换、绘制提示标记。
3.  `main.py`: 组装 `MainWindow`，连接 AI 线程信号，实现 PVE/PVP 切换和状态机流转。
